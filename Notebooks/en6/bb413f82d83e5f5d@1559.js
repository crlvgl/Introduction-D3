import define1 from "./450051d7f1174df8@255.js";
import define2 from "./1104ceb0818de884@99.js";

function _1(md){return(
md`# Learn D3: Animation (6/9)

> _Disclaimer:_ <br>
> _This notebook is a fork of [Mike Bostock](https://observablehq.com/user/@mbostock)s "[Learn D3](https://observablehq.com/@d3/learn-d3-animation?collection=@d3/learn-d3)" notebook series._ <br>
> _I only updated and changed the contents of the notebook to better fit our use case._ <br><br>
> _This notebook contains multiple cells and descriptions specifically for Observable notebooks, not for classic D3. I decided to keep them in the notebook because they do not have a equivalent for classic projects and are helpful when trying to understand how D3 actually works, rather than just viewing it as a blackbox._

Unlike graphics drawn on paper, computer graphics needn’t be static; like Frankenstein’s monster, they can come alive through animation!`
)}

function _replay(Inputs){return(
Inputs.button("Replay")
)}

function _3(replay,htl,width,height,d3,line,data,reveal,xAxis,yAxis)
{
  replay; // references the button above, causing this cell to run on click
  return htl.html`<svg viewBox="0 0 ${width} ${height}">
  ${d3.select(htl.svg`<path d="${line(data)}" fill="none" stroke="steelblue" stroke-width="1.5" stroke-miterlimit="1" stroke-dasharray="0,1"></path>`).call(reveal).node()}
  ${d3.select(htl.svg`<g>`).call(xAxis).node()}
  ${d3.select(htl.svg`<g>`).call(yAxis).node()}
</svg>`;
}


function _4(md){return(
md`The line chart above reveals progressively. This is somewhat gratuitous—motion should be used sparingly as it commands attention—but it at least reinforces that *x* represents time and introduces a touch of suspense to an otherwise ho-hum chart.`
)}

function _5(md){return(
md`The code here is similar to the axis rendering we saw previously: we select an SVG path element, call a function (*reveal*) to apply a transition, and lastly embed the element in the HTML template literal.`
)}

function _reveal(d3){return(
path => path.transition()
    .duration(5000)
    .ease(d3.easeLinear)
    .attrTween("stroke-dasharray", function() {
      const length = this.getTotalLength();
      return d3.interpolate(`0,${length}`, `${length},${length}`);
    })
)}

function _7(md){return(
md`Before we get into the minutiae of techniques, though, let’s take a step back to think about animation more generally.`
)}

function _8(md){return(
md`An animation is not a single graphic but a *sequence* of graphics over time. This sequence can be represented as a cell (or function) that returns the graphic for a given time *t*. For simplicity, we often use normalized time where *t* = 0 is the start of the animation and *t* = 1 is the end.`
)}

function _t(Scrubber,d3){return(
Scrubber(d3.ticks(0, 1, 200), {
  autoplay: false,
  loop: false,
  initial: 0,
  format: x => `t = ${x.toFixed(3)}`
})
)}

function _10(htl,width,height,line,data,lineLength,t,d3,xAxis,yAxis){return(
htl.html`<svg viewBox="0 0 ${width} ${height}">
  <path d="${line(data)}" fill="none" stroke="steelblue" stroke-width="1.5" stroke-miterlimit="1" stroke-dasharray="${lineLength * t},${lineLength}"></path>
  ${d3.select(htl.svg`<g>`).call(xAxis).node()}
  ${d3.select(htl.svg`<g>`).call(yAxis).node()}
</svg>`
)}

function _lineLength(htl,line,data){return(
htl.svg`<path d="${line(data)}">`.getTotalLength()
)}

function _12(md){return(
md`Our cell could theoretically return *any* graphic for a given time *t*, but often the graphic for time *t* is similar to the one for time *t* + ϵ. This similarity from frame to frame helps the viewer follow along. (Above, only the stroke-dasharray attribute animates; the rest of the graphic remains constant.) Hence, continuous animations are often defined by discrete keyframes with intermediate frames generated by interpolation, or [*tweening*](https://en.wikipedia.org/wiki/Inbetweening).`
)}

function _13(md){return(
md`Consider the stroke-dasharray attribute. It is two comma-separated numbers: the first is the length of the dash, and the second the length of the gap between dashes. If the dash length is zero, then the line will be invisible; if the dash length is as long as the line, then the line will be unbroken. By adjusting the dash length and keeping the gap at least as long as the line, we can control how much of the line is stroked. And we only need two keyframes: a zero-length dash and a line-length dash.`
)}

function _14(md){return(
md`To assist with animation (among other uses), D3 provides [interpolators](/collection/@d3/d3-interpolate). The most generic of these, [d3.interpolate](/@d3/d3-interpolate), accepts numbers, colors, strings-of-numbers, and even arrays and objects. Given a *start* and *end* value, d3.interpolate returns a function that takes a time 0 ≤ *t* ≤ 1 and returns the corresponding inbetween value.`
)}

function _strokeDasharray(d3,lineLength){return(
d3.interpolate(`0,${lineLength}`, `${lineLength},${lineLength}`)
)}

function _16(strokeDasharray,t){return(
strokeDasharray(t)
)}

function _17(md){return(
md`When defining a transition, you can either specify the interpolator explicitly (as above using [*transition*.attrTween](https://d3js.org/d3-transition/modifying#transition_attrTween)) or let D3 choose (using [*transition*.attr](https://d3js.org/d3-transition/modifying#transition_attr) or [*transition*.style](https://d3js.org/d3-transition/modifying#transition_style)). Being explicit allows more advanced interpolation methods such as [zooming](/@d3/d3-interpolatezoom), [gamma-corrected RGB blending](https://d3js.org/d3-interpolate/color#interpolateColor_gamma), or even [shape blending](/@mbostock/hello-flubber).`
)}

function _18(ramp,d3){return(
ramp(d3.interpolateRgb("steelblue", "orange"))
)}

function _19(ramp,d3){return(
ramp(d3.interpolateRgb.gamma(2.2)("steelblue", "orange"))
)}

function _20(md){return(
md`Animation is more than interpolation, however: it’s also timing. We need to redraw sixty times a second, and to compute the normalized time *t* based on real time and the desired start time and duration of the animation.

We’ve seen two timing methods so far.`
)}

function _21(md){return(
md`The first relies on D3’s transitions, creating an initial graphic and then starting a transition to modify it (interpolating the stroke-dasharray).`
)}

function _22(md){return(
md`The second relies on Observable’s dataflow, recreating the graphic whenever the referenced *t* changes and relying on a [scrubber](/@mbostock/scrubber) for timing. This is less efficient than the previous method because the graphic is created from scratch each frame, but easier to write. <br>
_[for obvious reasons this would not work in a classic project since HTML + Js doesn't have a dataflow like Observable notebooks.]_`
)}

function _23(md){return(
md`Observable has another powerful tool for controlling animation: [*generators*](/@observablehq/introduction-to-generators). When a generator cell yields a value, its execution is suspended until the next animation frame, up to sixty times per second. The yielded value can be as simple as an integer — or it can be an incrementally-updating SVG element! <br>
_[Generators are a JavaScript constructor and as such also work in classic projects.]_`
)}

function _replay2(Inputs){return(
Inputs.button("Replay")
)}

function* _25(replay2)
{
  replay2; // reference the button so this cell re-runs on click
  for (let i = 0, n = 300; i < n; ++i) {
    yield i;
  }
}


function* _26(replay2,htl,line,data,width,height,d3,xAxis,yAxis,lineLength)
{
  replay2; // reference the button so this cell re-runs on click

  const path = htl.svg`<path d="${line(data)}" fill="none" stroke="steelblue" stroke-width="1.5" stroke-miterlimit="1">`;

  const chart = htl.html`<svg viewBox="0 0 ${width} ${height}">
    ${path}
    ${d3.select(htl.svg`<g>`).call(xAxis).node()}
    ${d3.select(htl.svg`<g>`).call(yAxis).node()}
  </svg>`;

  for (let i = 0, n = 300; i < n; ++i) {
    const t = (i + 1) / n;
    path.setAttribute("stroke-dasharray", `${t * lineLength},${lineLength}`);
    yield chart;
  }
}


function _27(md){return(
md`Given the variety of possible approaches to animation in Observable _[and D3 as well]_, which should you use? It depends!`
)}

function _28(md){return(
md`If the graphic is simple enough that you can recreate it from scratch each frame — or if you don’t actually need animated transitions — then write the graphic declaratively. In other words, do nothing! Thanks to Observable’s dataflow, a “static” graphic can be made responsive, interactive, or animated without changing its code. <br>
_[Classic projects do not have a dataflow.]_`
)}

function _29(md){return(
md`On the other hand, for dynamic graphics of greater complexity — where performance necessitates efficient incremental updates — employ transitions or generators.`
)}

function _30(md){return(
md`You can also combine approaches. The graphic below is initially static, but exposes a *chart*.update method to transition to a given *x*-domain; this method is called by another cell when the selected value of the radio input changes. (This code is written using d3-selection rather than HTML template literals, but the graphic structure is the same as earlier examples, so try inferring the code’s meaning by comparison.) <br>
_[As such, this code snippet can be used in classic projects]_`
)}

function _timeframe(Inputs,d3,data){return(
Inputs.radio(new Map([
  ["All", d3.extent(data, d => d.date)],
  ["2009", [new Date("2009-01-01"), new Date("2010-01-01")]],
  ["2010", [new Date("2010-01-01"), new Date("2011-01-01")]],
  ["2011", [new Date("2011-01-01"), new Date("2012-01-01")]],
]), {key: "All"})
)}

function _chart(d3,width,height,x,y,data,xAxis,yAxis)
{
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  const zx = x.copy(); // x, but with a new domain.

  const line = d3.line()
      .x(d => zx(d.date))
      .y(d => y(d.close));

  const path = svg.append("path")
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-width", 1.5)
      .attr("stroke-miterlimit", 1)
      .attr("d", line(data));

  const gx = svg.append("g")
      .call(xAxis, zx);

  const gy = svg.append("g")
      .call(yAxis, y);

  return Object.assign(svg.node(), {
    update(domain) {
      const t = svg.transition().duration(750);
      zx.domain(domain);
      gx.transition(t).call(xAxis, zx);
      path.transition(t).attr("d", line(data));
    }
  });
}


function _update(chart,timeframe){return(
chart.update(timeframe)
)}

function _34(md){return(
md`By exposing one or more update methods, a chart can selectively animate transitions for specific value changes. If anything else changes, the chart falls back to passive reactivity and is redrawn from scratch.`
)}

function _35(md){return(
md`This example demonstrates another handy feature of D3 axes: by switching to [*transition*.call](https://d3js.org/d3-transition/control-flow#transition_call) instead of *selection*.call, the change in the *x*-axis is now animated rather than instantaneous, and synchronized with the transitioning path!`
)}

function _36(md){return(
md`The animations above conveniently involve only a single element: the chart’s line. What if you want to animate multiple elements? And what if the set of elements changes over time, with new elements entering and old elements exiting? Read on!

<a title="Learn D3: Joins" style="display: inline-flex; align-items: center; font: 600 14px var(--sans-serif);" href="/Notebooks/en7/index.html">Next<svg width="8" height="16" fill="none" stroke-width="1.8" style="margin-left: 0.25em; padding-top: 0.25em;"><path d="M2.75 11.25L5.25 8.25L2.75 5.25" stroke="currentColor"></path></svg></a>`
)}

function _37(md){return(
md`---

## Appendix

If you’re interested in designing effective animations, I highly recommend reading Heer and Robertson’s 2007 paper, [*Animated Transitions in Statistical Data Graphics*](http://vis.berkeley.edu/papers/animated_transitions/).`
)}

function _data(FileAttachment){return(
FileAttachment("aapl-bollinger.csv").csv({typed: true})
)}

function _line(d3,x,y){return(
d3.line().x(d => x(d.date)).y(d => y(d.close))
)}

function _x(d3,data,margin,width){return(
d3.scaleUtc()
    .domain(d3.extent(data, d => d.date))
    .range([margin.left, width - margin.right])
)}

function _y(d3,data,height,margin){return(
d3.scaleLinear()
    .domain([0, d3.max(data, d => d.upper)])
    .range([height - margin.bottom, margin.top])
)}

function _xAxis(x,height,margin,d3,width){return(
(g, scale = x) => g
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(scale).ticks(width / 80).tickSizeOuter(0))
)}

function _yAxis(y,margin,d3,height){return(
(g, scale = y) => g
    .attr("transform", `translate(${margin.left},0)`)
    .call(d3.axisLeft(scale).ticks(height / 40))
    .call(g => g.select(".domain").remove())
)}

function _height(){return(
240
)}

function _margin(){return(
{top: 20, right: 30, bottom: 30, left: 40}
)}

export default function define(runtime, observer) {
  const main = runtime.module();
  function toString() { return this.url; }
  const fileAttachments = new Map([
    ["aapl-bollinger.csv", {url: new URL("./files/68598443a16fce00a89f983b40c3b4c89b15827ac91726b864da942e4fad1b5cc19abaa1d3efd9855a7a2fadb3ef16f7c4365666eb572026a986b69d768bbc34.csv", import.meta.url), mimeType: "text/csv", toString}]
  ]);
  main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
  main.variable(observer()).define(["md"], _1);
  main.variable(observer("viewof replay")).define("viewof replay", ["Inputs"], _replay);
  main.variable(observer("replay")).define("replay", ["Generators", "viewof replay"], (G, _) => G.input(_));
  main.variable(observer()).define(["replay","htl","width","height","d3","line","data","reveal","xAxis","yAxis"], _3);
  main.variable(observer()).define(["md"], _4);
  main.variable(observer()).define(["md"], _5);
  main.variable(observer("reveal")).define("reveal", ["d3"], _reveal);
  main.variable(observer()).define(["md"], _7);
  main.variable(observer()).define(["md"], _8);
  main.variable(observer("viewof t")).define("viewof t", ["Scrubber","d3"], _t);
  main.variable(observer("t")).define("t", ["Generators", "viewof t"], (G, _) => G.input(_));
  main.variable(observer()).define(["htl","width","height","line","data","lineLength","t","d3","xAxis","yAxis"], _10);
  main.variable(observer("lineLength")).define("lineLength", ["htl","line","data"], _lineLength);
  main.variable(observer()).define(["md"], _12);
  main.variable(observer()).define(["md"], _13);
  main.variable(observer()).define(["md"], _14);
  main.variable(observer("strokeDasharray")).define("strokeDasharray", ["d3","lineLength"], _strokeDasharray);
  main.variable(observer()).define(["strokeDasharray","t"], _16);
  main.variable(observer()).define(["md"], _17);
  main.variable(observer()).define(["ramp","d3"], _18);
  main.variable(observer()).define(["ramp","d3"], _19);
  main.variable(observer()).define(["md"], _20);
  main.variable(observer()).define(["md"], _21);
  main.variable(observer()).define(["md"], _22);
  main.variable(observer()).define(["md"], _23);
  main.variable(observer("viewof replay2")).define("viewof replay2", ["Inputs"], _replay2);
  main.variable(observer("replay2")).define("replay2", ["Generators", "viewof replay2"], (G, _) => G.input(_));
  main.variable(observer()).define(["replay2"], _25);
  main.variable(observer()).define(["replay2","htl","line","data","width","height","d3","xAxis","yAxis","lineLength"], _26);
  main.variable(observer()).define(["md"], _27);
  main.variable(observer()).define(["md"], _28);
  main.variable(observer()).define(["md"], _29);
  main.variable(observer()).define(["md"], _30);
  main.variable(observer("viewof timeframe")).define("viewof timeframe", ["Inputs","d3","data"], _timeframe);
  main.variable(observer("timeframe")).define("timeframe", ["Generators", "viewof timeframe"], (G, _) => G.input(_));
  main.variable(observer("chart")).define("chart", ["d3","width","height","x","y","data","xAxis","yAxis"], _chart);
  main.variable(observer("update")).define("update", ["chart","timeframe"], _update);
  main.variable(observer()).define(["md"], _34);
  main.variable(observer()).define(["md"], _35);
  main.variable(observer()).define(["md"], _36);
  main.variable(observer()).define(["md"], _37);
  main.variable(observer("data")).define("data", ["FileAttachment"], _data);
  main.variable(observer("line")).define("line", ["d3","x","y"], _line);
  main.variable(observer("x")).define("x", ["d3","data","margin","width"], _x);
  main.variable(observer("y")).define("y", ["d3","data","height","margin"], _y);
  main.variable(observer("xAxis")).define("xAxis", ["x","height","margin","d3","width"], _xAxis);
  main.variable(observer("yAxis")).define("yAxis", ["y","margin","d3","height"], _yAxis);
  main.variable(observer("height")).define("height", _height);
  main.variable(observer("margin")).define("margin", _margin);
  const child1 = runtime.module(define1);
  main.import("Scrubber", child1);
  const child2 = runtime.module(define2);
  main.import("ramp", child2);
  return main;
}
